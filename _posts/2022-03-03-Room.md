---
title:  "[Android] Jetpack Room 라이브러리"
excerpt: "Kotlin에서의 Room 라이브러리 사용법"

categories:
  - Blog
tags:
  - Android
  - Kotlin
  - TIL
last_modified_at: 2022-03-03T16:00:00-05:00

toc: true
toc_sticky: true
---

참고 link : [안드로이드 Codelab](https://developer.android.com/codelabs/kotlin-android-training-room-database?index=..%2F..android-kotlin-fundamentals&hl=ko#2)

Android Jetpack의 데이터베이스 라이브러리인 Room에 대해 설명한다. 기술적으로, Room 라이브러리는 SQLite DB의 최상위에 있는 추상적인 레이어이다. SQLite는 데이터베이스 동작을 위해 SQL 언어를 사용하는데, Room 라이브러리는 이를 단순화하여 단순한 함수 호출만으로 데이터베이스를 쉽게 이용할 수 있도록 해준다.

# Entity와 Query

## Entity

- 데이터베이스에 저장할 속성을 가지고 있는 하나의 객체 혹은 개념
- 데이터베이스의 테이블은 entity class로 정의되며, 각 행은 해당 class의 instance를 나타냄
- Entity class는 Room 라이브러리에게 어떻게 정보를 표시하고 데이터베이스와 상호작용 할 것인지 나타낸다

## Query

- Query는 데이터베이스 하나의 테이블 혹은 여러 테이블의 조합의 데이터 혹은 정보에 대한 요청이거나, 데이터에 대한 작업 요청입니다.

# Entity 생성

- 각 Entity는 annotated data class로 정의되어야 합니다.

```kotlin
@Entity(tableName = "daily_sleep_quality_table")
data class SleepNight(
    @PrimaryKey(autoGenerate = true)
    var nightId: Long = 0L,

    @ColumnInfo(name = "start_time_milli")
    val startTimeMilli: Long = System.currentTimeMillis(),

    @ColumnInfo(name = "end_time_milli")
    var endTimeMilli: Long = startTimeMilli,

    @ColumnInfo(name = "quality_rating")
    var sleepQuality: Int = -1
)
```

# DAO 생성

- Entity에 대한 상호작용은 annotated interface로 정의되어야 하는데, 이것은 data access object (DAO) 라고 부릅니다. 데이터베이스 접근을 위한 커스텀 인터페이스라고 생각할 수 있습니다.
- 안드로이드에서 DAO는 데이터베이스 삽입, 삭제, 수정에 대한 기본 함수를 제공합니다. 이외의 query는 @Query annotation을 사용하여 정의할 수 있습니다.
- **Coroutine은 suspend function을 사용하므로 suspend 를 붙입니다. Coroutine 사용은 필수가 아니므로 suspend 키워드는 제거해도 됩니다.**

```kotlin
@Dao
interface SleepDatabaseDao {
    @Insert
    suspend fun insert(night : SleepNight)

    @Update
    suspend fun update(night : SleepNight)

    @Query("SELECT * from daily_sleep_quality_table WHERE nightId = :key")
    suspend fun get(key : Long) : SleepNight?

    @Query("DELETE FROM daily_sleep_quality_table")
    suspend fun clear()

    @Query("SELECT * FROM daily_sleep_quality_table ORDER BY nightId DESC LIMIT 1")
    suspend fun getTonight(): SleepNight?

    @Query("SELECT * FROM daily_sleep_quality_table ORDER BY nightId DESC")
    fun getAllNights() : LiveData<List<SleepNight>>
}
```

# Room 데이터베이스 생성

- 앞에서 생성한 Entity와 DAO 인터페이스를 이용하는 Room database를 생성합니다.
- 기본적인 원리는, abstract database holder class를 @Database annotation과 함께 생성합니다. 이 클래스는 데이터베이스의 객체를 생성하여 반환하는 하나의 함수만을 가지고 있습니다. 이미 생성된 객체가 있다면 그것을 반환합니다. (Singleton)

```kotlin
@Database(entities = [SleepNight::class], version = 1, exportSchema = false) // Entity 정의, Schema 변경 시 version up
abstract class SleepDatabase : RoomDatabase() {
   abstract val sleepDatabaseDao: SleepDatabaseDao // DAO 선언. 여러 개의 DAO를 가질 수 있음.

   companion object {
       @Volatile // Multi-Thread safe 하도록 Volatile 선언
       private var INSTANCE: SleepDatabase? = null

       fun getInstance(context: Context): SleepDatabase {
           synchronized(this) {
               var instance = INSTANCE

               if (instance == null) {
                   instance = Room.databaseBuilder(
                        context.applicationContext,
                        SleepDatabase::class.java,
                        "sleep_history_database"
                   )
                    .fallbackToDestructiveMigration()
                    .build()
                   INSTANCE = instance
               }
               return instance
           }
       }
   }
}
```

# Coroutines 에서 Room 라이브러리 이용

- Coroutine

```kotlin
fun onStopTracking() {
    val database = SleepDatabase.getInstance(application).sleepDatabaseDao
    viewModelScope.launch { // ViewModel에서 실행하므로 viewModelScope
        val newSleep = SleepNight()
        insert(newSleep)
    }
}
```